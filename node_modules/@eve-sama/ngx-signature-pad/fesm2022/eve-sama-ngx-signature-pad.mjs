import * as i0 from '@angular/core';
import { EventEmitter, Component, Input, Output, ViewChild, NgModule } from '@angular/core';
import SignaturePad from 'signature_pad';
import { TemplatePortal } from '@angular/cdk/portal';
import * as i1 from '@angular/cdk/overlay';
import { OverlayModule } from '@angular/cdk/overlay';
import * as i2 from '@angular/common';
import { CommonModule } from '@angular/common';

class NgxSignaturePadComponent {
    renderer2;
    overlay;
    viewContainerRef;
    // #region The object of dependency 'siganture_pad'
    smallPad;
    bigPad;
    // #endregion
    // #region The object of canvas
    smallCanvas;
    bigCanvas;
    // #endregion
    // #region CDK
    overlayRef;
    portal;
    // #endregion
    signDataHistory = [];
    fullScreenWidth;
    fullScreenHeight;
    _isEmpty = true;
    isFullScreen = false;
    sectionHeight;
    get activePad() {
        return this.isFullScreen ? this.bigPad : this.smallPad;
    }
    options = {};
    beginSign = new EventEmitter();
    endSign = new EventEmitter();
    fullScreenTpl;
    nspSmall;
    nspBig;
    fullScreen() {
        this.portal = new TemplatePortal(this.fullScreenTpl, this.viewContainerRef);
        this.overlayRef = this.overlay.create({
            positionStrategy: this.overlay.position().global(),
            scrollStrategy: this.overlay.scrollStrategies.block(),
            height: '100%',
            width: '100%'
        });
        this.overlayRef.attach(this.portal);
        setTimeout(() => {
            this.initBigPad();
            // #region Copy miniScreen's content to fullScreen
            const { width: miniScreenWidth, height: miniScreenHeight } = this.options;
            const ctx = this.bigCanvas.getContext('2d');
            ctx.save();
            ctx.translate(this.fullScreenWidth, 0);
            ctx.rotate((90 * Math.PI) / 180);
            ctx.drawImage(this.smallCanvas, 0, 0, miniScreenWidth, miniScreenHeight, 0, 0, this.fullScreenHeight, this.fullScreenWidth);
            ctx.restore();
            // #endregion
        }, 0);
        this.isFullScreen = true;
    }
    miniScreen() {
        this.smallPad.clear();
        // #region Copy fullScreen's content to miniScreen
        const { width: miniScreenWidth, height: miniScreenHeight } = this.options;
        const widthScale = miniScreenWidth / this.fullScreenHeight;
        const heightScale = miniScreenHeight / this.fullScreenWidth;
        const ctx = this.smallCanvas.getContext('2d');
        ctx.save();
        ctx.translate(0, miniScreenHeight);
        ctx.rotate((-90 * Math.PI) / 180);
        ctx.drawImage(this.bigCanvas, 0, 0, this.fullScreenWidth, this.fullScreenHeight, 0, 0, this.fullScreenWidth * widthScale, this.fullScreenHeight * heightScale);
        ctx.restore();
        // #endregion
        this.overlayRef.dispose();
        this.bigCanvas = null;
        this.bigPad = null;
        this.isFullScreen = false;
    }
    /** Returns signature image as an array of point groups */
    toData() {
        return this.activePad.toData();
    }
    /** Draws signature image from an array of point groups */
    fromData(pointGroups) {
        this.activePad.fromData(pointGroups);
    }
    toDataURL(type) {
        switch (type) {
            case 'image/jpeg':
                return this.activePad.toDataURL('image/jpeg');
            case 'image/svg+xml':
                return this.activePad.toDataURL('image/svg+xml');
            default:
                return this.activePad.toDataURL();
        }
    }
    fromDataURL(dataUrl, options, callback) {
        this.activePad.fromDataURL(dataUrl, options, callback);
    }
    revert() {
        this.signDataHistory.pop();
        this.fromData(this.signDataHistory);
        if (this.signDataHistory.length === 0) {
            this.setEmpty();
        }
    }
    // Clears the canvas
    clear() {
        this.setEmpty();
        this.signDataHistory = [];
        this.activePad.clear();
    }
    /** Return true if canvas is empty, otherwise return false */
    isEmpty() {
        return this._isEmpty;
    }
    /** Set canvas's state as dirty */
    setDirty() {
        this._isEmpty = false;
    }
    /** Set canvas's state as empty */
    setEmpty() {
        this._isEmpty = true;
    }
    getContext() {
        return this.isFullScreen ? this.bigCanvas.getContext('2d') : this.smallCanvas.getContext('2d');
    }
    initBigPad() {
        this.bigCanvas = this.nspBig.nativeElement; //document.querySelector('#nsp-big');
        const fullScreenOptions = JSON.parse(JSON.stringify(this.options));
        // Calculate the fullScreen pad's size
        this.fullScreenWidth = document.documentElement.clientWidth;
        const { width: miniScreenWidth, height: miniScreenHeight } = this.options;
        this.fullScreenHeight = (this.fullScreenWidth * miniScreenWidth) / miniScreenHeight;
        // Calculate section size
        const viewHeight = document.documentElement.clientHeight;
        const space = viewHeight - this.fullScreenHeight;
        this.sectionHeight = space / 2;
        // Init pad
        fullScreenOptions.width = this.fullScreenWidth;
        fullScreenOptions.height = this.fullScreenHeight;
        const { css } = fullScreenOptions;
        this.bigCanvas.width = this.fullScreenWidth;
        this.bigCanvas.height = this.fullScreenHeight;
        for (const key in css) {
            if (Object.prototype.hasOwnProperty.call(css, key)) {
                const value = css[key];
                this.renderer2.setStyle(this.bigCanvas, key, value);
            }
        }
        this.bigPad = new SignaturePad(this.bigCanvas, fullScreenOptions);
        this.bigPad.onBegin = this._onBegin.bind(this);
        this.bigPad.onEnd = this._onEnd.bind(this);
    }
    initSmallPad() {
        this.smallCanvas = this.nspSmall.nativeElement; //document.querySelector('#nsp-small');
        const { width, height, css } = this.options;
        this.options.width = width ? width : 300;
        this.options.height = height ? height : 150;
        this.smallCanvas.width = this.options.width;
        this.smallCanvas.height = this.options.height;
        for (const key in css) {
            if (Object.prototype.hasOwnProperty.call(css, key)) {
                const value = css[key];
                this.renderer2.setStyle(this.smallCanvas, key, value);
            }
        }
        this.smallPad = new SignaturePad(this.smallCanvas, this.options);
        this.smallPad.onBegin = this._onBegin.bind(this);
        this.smallPad.onEnd = this._onEnd.bind(this);
    }
    _onBegin() {
        this.setDirty(); // When user draws, set state as dirty
        this.beginSign.emit();
    }
    _onEnd() {
        this.signDataHistory = this.toData();
        this.endSign.emit();
    }
    setPadAttribute(key, value) {
        if (this.bigPad) {
            this.bigPad[key] = value;
        }
        this.smallPad[key] = value;
    }
    constructor(renderer2, overlay, viewContainerRef) {
        this.renderer2 = renderer2;
        this.overlay = overlay;
        this.viewContainerRef = viewContainerRef;
    }
    ngAfterViewInit() {
        this.initSmallPad();
    }
    ngOnChanges(changes) {
        if (changes.options.firstChange) {
            return;
        }
        const { dotSize, minWidth, maxWidth, throttle, minDistance, backgroundColor, penColor, velocityFilterWeight, width, height, css } = changes.options.currentValue;
        if (dotSize) {
            this.setPadAttribute('dotSize', dotSize);
        }
        if (minWidth) {
            this.setPadAttribute('minWidth', minWidth);
        }
        if (maxWidth) {
            this.setPadAttribute('maxWidth', maxWidth);
        }
        if (throttle) {
            this.setPadAttribute('throttle', throttle);
        }
        if (minDistance) {
            this.setPadAttribute('minDistance', minDistance);
        }
        if (backgroundColor) {
            this.setPadAttribute('backgroundColor', backgroundColor);
        }
        if (penColor) {
            this.setPadAttribute('penColor', penColor);
        }
        if (velocityFilterWeight) {
            this.setPadAttribute('velocityFilterWeight', velocityFilterWeight);
        }
        if (width || height) {
            const { width: previousWidth, height: previousHeight } = changes.options.previousValue;
            const data = this.smallPad.toDataURL();
            const image = new Image();
            image.src = data;
            image.onload = () => {
                this.initSmallPad();
                const ctx = this.smallCanvas.getContext('2d');
                ctx.drawImage(image, 0, 0, previousWidth, previousHeight, 0, 0, width, height);
            };
        }
        if (css) {
            if (this.bigCanvas) {
                for (const key in css) {
                    if (Object.prototype.hasOwnProperty.call(css, key)) {
                        const value = css[key];
                        this.renderer2.setStyle(this.bigCanvas, key, value);
                    }
                }
            }
            if (this.smallCanvas) {
                for (const key in css) {
                    if (Object.prototype.hasOwnProperty.call(css, key)) {
                        const value = css[key];
                        this.renderer2.setStyle(this.smallCanvas, key, value);
                    }
                }
            }
        }
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.0.2", ngImport: i0, type: NgxSignaturePadComponent, deps: [{ token: i0.Renderer2 }, { token: i1.Overlay }, { token: i0.ViewContainerRef }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.0.2", type: NgxSignaturePadComponent, selector: "ngx-signature-pad", inputs: { options: "options" }, outputs: { beginSign: "beginSign", endSign: "endSign" }, viewQueries: [{ propertyName: "fullScreenTpl", first: true, predicate: ["fullScreenTpl"], descendants: true }, { propertyName: "nspSmall", first: true, predicate: ["nspSmall"], descendants: true }, { propertyName: "nspBig", first: true, predicate: ["nspBig"], descendants: true }], usesOnChanges: true, ngImport: i0, template: "<canvas #nspSmall></canvas>\n\n<ng-template #fullScreenTpl>\n  <div class=\"nsp-container\">\n    <div class=\"section left\" style=\"width: 100%;\" [ngStyle]=\"{'height': sectionHeight + 'px'}\"></div>\n    <canvas #nspBig></canvas>\n    <div class=\"section right\" style=\"width: 100%;\" [ngStyle]=\"{'height': sectionHeight + 'px'}\"></div>\n    <ng-content></ng-content>\n  </div>\n</ng-template>", styles: [".nsp-container{display:flex;flex-direction:column;position:fixed;left:0;top:0;width:100%;height:100vh;background:#fff}.nsp-container .section{flex:1}.nsp-container .section.left{border-bottom:2px dashed #dedee5}.nsp-container .section.right{border-top:2px dashed #dedee5}\n"], dependencies: [{ kind: "directive", type: i2.NgStyle, selector: "[ngStyle]", inputs: ["ngStyle"] }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.0.2", ngImport: i0, type: NgxSignaturePadComponent, decorators: [{
            type: Component,
            args: [{ selector: 'ngx-signature-pad', template: "<canvas #nspSmall></canvas>\n\n<ng-template #fullScreenTpl>\n  <div class=\"nsp-container\">\n    <div class=\"section left\" style=\"width: 100%;\" [ngStyle]=\"{'height': sectionHeight + 'px'}\"></div>\n    <canvas #nspBig></canvas>\n    <div class=\"section right\" style=\"width: 100%;\" [ngStyle]=\"{'height': sectionHeight + 'px'}\"></div>\n    <ng-content></ng-content>\n  </div>\n</ng-template>", styles: [".nsp-container{display:flex;flex-direction:column;position:fixed;left:0;top:0;width:100%;height:100vh;background:#fff}.nsp-container .section{flex:1}.nsp-container .section.left{border-bottom:2px dashed #dedee5}.nsp-container .section.right{border-top:2px dashed #dedee5}\n"] }]
        }], ctorParameters: function () { return [{ type: i0.Renderer2 }, { type: i1.Overlay }, { type: i0.ViewContainerRef }]; }, propDecorators: { options: [{
                type: Input
            }], beginSign: [{
                type: Output
            }], endSign: [{
                type: Output
            }], fullScreenTpl: [{
                type: ViewChild,
                args: ['fullScreenTpl']
            }], nspSmall: [{
                type: ViewChild,
                args: ['nspSmall', { static: false }]
            }], nspBig: [{
                type: ViewChild,
                args: ['nspBig', { static: false }]
            }] } });

class NgxSignaturePadModule {
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.0.2", ngImport: i0, type: NgxSignaturePadModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
    static ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "16.0.2", ngImport: i0, type: NgxSignaturePadModule, declarations: [NgxSignaturePadComponent], imports: [CommonModule, OverlayModule], exports: [NgxSignaturePadComponent] });
    static ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "16.0.2", ngImport: i0, type: NgxSignaturePadModule, imports: [CommonModule, OverlayModule] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.0.2", ngImport: i0, type: NgxSignaturePadModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [CommonModule, OverlayModule],
                    declarations: [NgxSignaturePadComponent],
                    exports: [NgxSignaturePadComponent]
                }]
        }] });

/*
 * Public API Surface of ngx-signature-pad
 */

/**
 * Generated bundle index. Do not edit.
 */

export { NgxSignaturePadComponent, NgxSignaturePadModule };
//# sourceMappingURL=eve-sama-ngx-signature-pad.mjs.map
